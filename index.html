<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tweet Wall</title>

  <style>
    :root{
      --bg:#0f1419; --card:#0b0f13; --text:#e6edf3; --muted:#8b98a5; --accent:#1d9bf0;
      --pad:16px; --radius:14px; --gap:12px; --maxw:760px;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"}
    header{
      position:sticky; top:0; z-index:5; backdrop-filter:saturate(180%) blur(10px);
      background-color:rgba(15,20,25,.75); border-bottom:1px solid rgba(255,255,255,.06);
    }
    .wrap{max-width:var(--maxw); margin:0 auto; padding:10px var(--pad)}
    h1{margin:0; font-size:20px}
    .meta{color:var(--muted); font-size:13px; margin-top:4px}
    .controls{display:flex; gap:var(--gap); margin-top:10px}
    button{
      background:var(--accent); color:#fff; border:none; border-radius:10px; padding:10px 14px;
      font-weight:600; cursor:pointer; transition:transform .05s ease, opacity .2s ease;
    }
    button:disabled{opacity:.4; cursor:not-allowed}
    main{max-width:var(--maxw); margin:0 auto; padding:var(--pad)}
    .grid{display:grid; gap:16px}
    .card{
      background:var(--card); border:1px solid rgba(255,255,255,.06);
      border-radius:var(--radius); padding:12px;
    }
    .err{color:#ff6b6b; white-space:pre-wrap}
    .footer-space{height:60px}
    .small{color:var(--muted); font-size:12px}

    /* NEW: tiny “replied · X ago” badge */
    .badge{
      display:inline-block;
      font-size:12px;
      color:#cbd5e1;
      background:rgba(29,155,240,.12);
      border:1px solid rgba(29,155,240,.35);
      padding:2px 8px;
      border-radius:999px;
      margin-bottom:6px;
    }
  </style>

  <!-- Twitter widgets -->
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Tweet Wall</h1>
      <div class="meta">
        <span id="stats">Loading…</span>
      </div>
      <div class="controls">
        <button id="refreshBtn">Refresh</button>
        <button id="loadMoreBtn" disabled>Load more</button>
        <span class="small" id="hint"></span>
      </div>
    </div>
  </header>

  <main>
    <div id="feed" class="grid"></div>
    <div class="footer-space"></div>
    <div id="error" class="err" style="display:none;"></div>
  </main>

  <script>
    // -------- Page limits (safe defaults) --------
    const MAX_SHOW   = 60;  // max tweets rendered on page
    const BATCH_SIZE = 6;   // how many to render per click/auto-batch
    // --------------------------------------------

    const FEED  = document.getElementById('feed');
    const STATS = document.getElementById('stats');
    const ERR   = document.getElementById('error');
    const BTN1  = document.getElementById('refreshBtn');
    const BTN2  = document.getElementById('loadMoreBtn');
    const HINT  = document.getElementById('hint');

    // We’ll keep objects { id, repliedAt } so we can show the badge
    let tweetItems = []; // full (capped) list for this page
    let idx = 0;         // next index to render

    // Safe date → epoch ms
    function eTime(str) {
      if (!str) return 0;
      const d = new Date(str);
      return Number.isNaN(d.getTime()) ? 0 : d.getTime();
    }

    // “3m / 2h / 1d” formatter
    function timeAgo(ms) {
      const s = Math.floor((Date.now() - ms) / 1000);
      if (s < 60) return `${s}s`;
      const m = Math.floor(s / 60);
      if (m < 60) return `${m}m`;
      const h = Math.floor(m / 60);
      if (h < 24) return `${h}h`;
      const d = Math.floor(h / 24);
      return `${d}d`;
    }

    // Extract tweet ID from URL
    function toId(url) {
      if (!url) return null;
      const m = String(url).match(/status\/(\d+)/);
      return m ? m[1] : null;
    }

    // Build one tweet embed container (UNCHANGED look, just adds badge if available)
    function tweetEmbedHtml(item) {
      const { id, repliedAt } = item;
      const url = `https://twitter.com/anyuser/status/${id}`;
      const badge = repliedAt ? `<div class="badge" title="${new Date(repliedAt).toLocaleString()}">replied · ${timeAgo(eTime(repliedAt))} ago</div>` : '';
      return `
        <div class="card">
          ${badge}
          <blockquote class="twitter-tweet" data-dnt="true" data-theme="dark">
            <a href="${url}"></a>
          </blockquote>
        </div>`;
    }

    async function loadData() {
      try {
        ERR.style.display = 'none';
        FEED.innerHTML = '';
        STATS.textContent = 'Loading…';
        BTN2.disabled = true;

        const bust = Date.now();
        const r = await fetch(`tweets.json?v=${bust}`, { cache: 'no-store' });
        if (!r.ok) throw new Error('Failed to fetch tweets.json: ' + r.status);

        const arr = await r.json();
        const list = Array.isArray(arr) ? arr : [];

        // Accept both strings and {url,repliedAt}; normalize to {id, repliedAt}
        const entries = list.map(item => {
          if (typeof item === 'string') return { id: toId(item), repliedAt: null };
          return { id: toId(item.url), repliedAt: item.repliedAt || null };
        }).filter(e => !!e.id);

        // Sort newest first by repliedAt if present (falls back to 0 → end)
        entries.sort((a, b) => eTime(b.repliedAt) - eTime(a.repliedAt));

        // Cap to MAX_SHOW for front-end
        tweetItems = entries.slice(0, MAX_SHOW);
        idx = 0;

        STATS.textContent = `Loaded ${tweetItems.length} tweet URL${tweetItems.length === 1 ? '' : 's'} (newest first).`;
        HINT.textContent = tweetItems.length > BATCH_SIZE ? `Showing ${BATCH_SIZE}, click “Load more” for more.` : '';

        // Auto-render first batch
        renderNextBatch();
      } catch (e) {
        console.error(e);
        ERR.textContent = e.message || String(e);
        ERR.style.display = 'block';
      }
    }

    function renderNextBatch() {
      const next = tweetItems.slice(idx, idx + BATCH_SIZE);
      if (!next.length) {
        BTN2.disabled = true;
        HINT.textContent = 'End of list.';
        return;
      }

      const html = next.map(item => tweetEmbedHtml(item)).join('');
      const wrap = document.createElement('div');
      wrap.innerHTML = html;
      FEED.appendChild(wrap);

      // Ask Twitter to hydrate new embeds
      if (window.twttr && twttr.widgets && twttr.widgets.load) {
        twttr.widgets.load(wrap);
      }

      idx += next.length;
      BTN2.disabled = idx >= tweetItems.length;
      HINT.textContent = BTN2.disabled ? 'End of list.' : `Showing ${idx} of ${tweetItems.length}.`;
    }

    BTN1.addEventListener('click', loadData);
    BTN2.addEventListener('click', renderNextBatch);

    // Initial load
    loadData();
  </script>
</body>
</html>
