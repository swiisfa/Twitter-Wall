<script>
(async function () {
  const FEED = document.getElementById('feed');
  const STATS = document.getElementById('stats');
  const ERR = document.getElementById('errors');
  const BTN1 = document.getElementById('loadMore');
  const BTN2 = document.getElementById('loadMoreBottom');

  // ↓↓↓ tweaked here
  const BATCH = 6;     // render per step (was 10)
  const MAX_SHOW = 60; // safety cap on total tweets (was 120)

  let tweetIds = [];
  let idx = 0;
  let rendering = false;

  function toId(u) {
    if (typeof u !== 'string') return null;
    u = u.trim().replace('https://x.com/', 'https://twitter.com/');
    const m = u.match(/twitter\.com\/[^/]+\/status\/(\d+)/i);
    return m ? m[1] : null;
  }

  function uniq(arr) {
    const s = new Set();
    const out = [];
    for (const v of arr) {
      if (!s.has(v)) { s.add(v); out.push(v); }
    }
    return out;
  }

  async function loadData() {
    try {
      // ↓↓↓ cache-buster here
      const bust = Date.now();
      const r = await fetch(`tweets.json?v=${bust}`, { cache: 'no-store' });
      if (!r.ok) throw new Error('Failed to fetch tweets.json: ' + r.status);
      const arr = await r.json();
      let ids = Array.isArray(arr) ? arr.map(toId).filter(Boolean) : [];
      ids = ids.reverse();             // newest first
      ids = ids.slice(0, MAX_SHOW);    // cap
      ids = uniq(ids);
      tweetIds = ids;
      STATS.textContent = `Loaded ${tweetIds.length} tweet URLs (newest first).`;
      if (!tweetIds.length) BTN1.disabled = BTN2.disabled = true;
    } catch (e) {
      ERR.textContent = e.message;
    }
  }

  async function renderBatch() {
    if (rendering) return;
    rendering = true;

    const end = Math.min(idx + BATCH, tweetIds.length);
    const slice = tweetIds.slice(idx, end);

    for (const id of slice) {
      const card = document.createElement('div');
      card.className = 'tweet-card';
      FEED.appendChild(card);

      try {
        await ensureWidgets();
        await twttr.widgets.createTweet(id, card, { theme: 'dark', align: 'center' });
      } catch (e) {
        card.textContent = 'Failed to render tweet ' + id;
        console.error(e);
      }
    }

    idx = end;
    if (idx >= tweetIds.length) {
      BTN1.disabled = BTN2.disabled = true;
    }
    rendering = false;
  }

  function ensureWidgets() {
    return new Promise((resolve) => {
      if (window.twttr && twttr.widgets && twttr.widgets.createTweet) return resolve();
      const i = setInterval(() => {
        if (window.twttr && twttr.widgets && twttr.widgets.createTweet) {
          clearInterval(i);
          resolve();
        }
      }, 50);
    });
  }

  // auto-load more on scroll near bottom
  const sentinel = document.createElement('div');
  FEED.after(sentinel);
  const io = new IntersectionObserver((entries) => {
    if (entries.some(e => e.isIntersecting)) renderBatch();
  }, { rootMargin: '800px' });
  io.observe(sentinel);

  BTN1.addEventListener('click', renderBatch);
  BTN2.addEventListener('click', renderBatch);

  await loadData();
  await renderBatch(); // first batch
})();
</script>
