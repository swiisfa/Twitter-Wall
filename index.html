<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tweet Wall</title>

  <style>
    :root{
      --bg:#0f1419; --card:#0b0f13; --text:#e6edf3; --muted:#8b98a5; --accent:#1d9bf0;
      --pad:16px; --radius:14px; --gap:12px; --maxw:760px;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"}
    header{
      position:sticky; top:0; z-index:5; backdrop-filter:saturate(180%) blur(10px);
      background-color:rgba(15,20,25,.75); border-bottom:1px solid rgba(255,255,255,.06);
    }
    .wrap{max-width:var(--maxw); margin:0 auto; padding:10px var(--pad)}
    h1{margin:0; font-size:20px}
    .meta{color:var(--muted); font-size:13px; margin-top:4px}
    .controls{display:flex; gap:var(--gap); margin-top:10px}
    button{
      background:var(--accent); color:#fff; border:none; border-radius:10px; padding:10px 14px;
      font-weight:600; cursor:pointer; transition:transform .05s ease, opacity .2s ease;
    }
    button:disabled{opacity:.4; cursor:not-allowed}
    main{max-width:var(--maxw); margin:0 auto; padding:var(--pad)}
    .grid{display:grid; gap:16px}
    .card{
      background:var(--card); border:1px solid rgba(255,255,255,.06);
      border-radius:var(--radius); padding:12px;
    }
    .err{color:#ff6b6b; white-space:pre-wrap}
    .footer-space{height:60px}
    .small{color:var(--muted); font-size:12px}
  </style>

  <!-- Twitter widgets -->
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Tweet Wall</h1>
      <div class="meta">
        <span id="stats">Loading…</span>
      </div>
      <div class="controls">
        <button id="refreshBtn">Refresh</button>
        <button id="loadMoreBtn" disabled>Load more</button>
        <span class="small" id="hint"></span>
      </div>
    </div>
  </header>

  <main>
    <div id="feed" class="grid"></div>
    <div class="footer-space"></div>
    <div id="error" class="err" style="display:none;"></div>
  </main>

  <script>
    // -------- Page limits (safe defaults) --------
    const MAX_SHOW   = 60;  // max tweets rendered on page
    const BATCH_SIZE = 6;   // how many to render per click/auto-batch
    // --------------------------------------------

    const FEED  = document.getElementById('feed');
    const STATS = document.getElementById('stats');
    const ERR   = document.getElementById('error');
    const BTN1  = document.getElementById('refreshBtn');
    const BTN2  = document.getElementById('loadMoreBtn');
    const HINT  = document.getElementById('hint');

    // Global state for paging
    let STATE = { entries: [], idx: 0 };

    // Helpers
    function eTime(str) {
      if (!str) return 0;
      const d = new Date(str);
      return Number.isNaN(d.getTime()) ? 0 : d.getTime();
    }
    function toId(url) {
      if (!url) return null;
      const m = String(url).match(/status\/(\d+)/);
      return m ? m[1] : null;
    }
    function timeAgo(str) {
      if (!str) return '';
      const d = new Date(str);
      const ms = Date.now() - d.getTime();
      if (isNaN(ms) || ms < 0) return '';
      const m = Math.floor(ms / 60000);
      if (m < 1)  return 'just now';
      if (m < 60) return `${m}m ago`;
      const h = Math.floor(m / 60);
      if (h < 24) return `${h}h ago`;
      const dys = Math.floor(h / 24);
      return `${dys}d ago`;
    }

    // Build tweet embed + meta ("by @user • 3m ago")
    function tweetEmbedHtml(entry) {
      const id   = entry.id;
      const url  = `https://twitter.com/anyuser/status/${id}`;
      const who  = Array.isArray(entry.repliers) && entry.repliers.length
                    ? entry.repliers.join(', ')
                    : '';
      const when = timeAgo(entry.repliedAt);

      const meta = (who || when)
        ? `<div class="small" style="margin:4px 0 ${who && when ? '8px' : '6px'} 0;">
             ${who ? `by ${who}` : ''}${who && when ? ' • ' : ''}${when || ''}
           </div>`
        : '';

      return `
        <div class="card">
          ${meta}
          <blockquote class="twitter-tweet" data-dnt="true" data-theme="dark">
            <a href="${url}"></a>
          </blockquote>
        </div>`;
    }

    async function loadData() {
      try {
        ERR.style.display = 'none';
        FEED.innerHTML = '';
        STATS.textContent = 'Loading…';
        BTN2.disabled = true;

        const bust = Date.now();
        const r = await fetch(`tweets.json?v=${bust}`, { cache: 'no-store' });
        if (!r.ok) throw new Error('Failed to fetch tweets.json: ' + r.status);

        const arr = await r.json();
        const list = Array.isArray(arr) ? arr : [];

        // Accept strings or objects; normalize to {id, repliedAt, repliers[]}
        const entries = list.map(item => {
          if (typeof item === 'string') {
            const id = toId(item);
            return id ? { id, repliedAt: null, repliers: [] } : null;
          }
          const id = toId(item.url || '');
          if (!id) return null;
          const repliers = Array.isArray(item.repliers) ? item.repliers : [];
          return {
            id,
            repliedAt: item.repliedAt || null,
            repliers
          };
        }).filter(Boolean);

        // newest first by repliedAt
        entries.sort((a, b) => eTime(b.repliedAt) - eTime(a.repliedAt));

        // cap for front-end
        const capped = entries.slice(0, MAX_SHOW);

        STATE = { entries: capped, idx: 0 };

        STATS.textContent = `Loaded ${capped.length} tweet URL${capped.length === 1 ? '' : 's'} (newest first).`;
        HINT.textContent  = capped.length > BATCH_SIZE ? `Showing ${BATCH_SIZE}, click “Load more” for more.` : '';

        renderNextBatch();
      } catch (e) {
        console.error(e);
        ERR.textContent = e.message || String(e);
        ERR.style.display = 'block';
      }
    }

    function renderNextBatch() {
      const next = STATE.entries.slice(STATE.idx, STATE.idx + BATCH_SIZE);
      if (!next.length) {
        BTN2.disabled = true;
        HINT.textContent = 'End of list.';
        return;
      }

      const html = next.map(entry => tweetEmbedHtml(entry)).join('');
      const wrap = document.createElement('div');
      wrap.innerHTML = html;
      FEED.appendChild(wrap);

      if (window.twttr && twttr.widgets && twttr.widgets.load) {
        twttr.widgets.load(wrap);
      }

      STATE.idx += next.length;
      BTN2.disabled = STATE.idx >= STATE.entries.length;
      HINT.textContent = BTN2.disabled ? 'End of list.' : `Showing ${STATE.idx} of ${STATE.entries.length}.`;
    }

    // Buttons
    document.getElementById('refreshBtn').addEventListener('click', loadData);
    document.getElementById('loadMoreBtn').addEventListener('click', renderNextBatch);

    // Initial load
    loadData();
  </script>
</body>
</html>
